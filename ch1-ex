nc (+ 3 5))
  (inc (inc (+ 2 5)))
  (inc (inc (inc (+ 1 5))))
  (inc (inc (inc (inc (+ 0 5)))))
  (inc (inc (inc (inc 5))))
  (inc (inc (inc 6)))
  (inc (inc 7))
  (inc 8)
  9
2 (+ 4 5)
  (+ 3 6)
  (+ 2 7)
  (+ 1 8)
  (+ 0 9)
  9

2 iterative 1 recursive

E1.10
(A 1 10)
(* 2 (A (1 9))
(* 2 (* 2 A (1 8))))
(* 2 (* 2 (* 2 A ( 1 7))))
(* 2 (* 2 (* 2 (* 2 A (1 6)))))
(* 2 (* 2 (* 2 (* 2 (* 2 A (1 5))))))
(* 2 (* 2 (* 2 (* 2 (* 2 (* 2 A (1 4)))))))
(* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 A (1 3)))))))
(* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (*2 A (1 2))))))
(* 2 (* 2 (* 2 (* 2 (* 2 (*2  (* 2 (*2 (*2 A (1 1))))))
(* 2 (* 2 (* 2 (* 2 (* 2 (*2  (*2  (*2  (*2 2)))))
2^10

(A 2 4)
(A 1 A (2 3))
2^(A 1 A (2 2))
2^(2^A(1 A (2 1)))
2^(2^(2^2))


(A 3 3)
(A 2 A (2 2))
(A 2 2^2)
2^2^2^2

(define (f n) (A 0 n)) f => 2*n
(define (g n) (A 1 n)) g => 2^n
(define (h n) (A 2 n)) h => 2^2…^2 (n 2)

E1.11
iterative
(define (f n)
 (f-iter 2 1 0 n))
(define (f-iter a b c counter)
    (cond ((= counter 2) a)
          ((= counter 1) b)
          ((= counter 0) c)
          (else (f-iter (+ a (+ (* 2 b) (* 3 c)))
                        a
                        b
                        (- counter 1)))))

recursive
(define (f n)
    (if ( < n 3)
        n
        ( + (f ( - n 1))
            ( + (* 2 (f (- n 2)))
                (* 3 (f (- n 3)))))))

E1.12
recursive 
(define (pascal level idx)
    ( if (or ( = idx 1)  
             ( = idx level))
         1
         ( + (pascal (- level 1)
                     (- idx 1))
             (pascal (- level 1)
                     idx))))

E1.13
带入求左右两边相等就可以了。

E1.14
(count-change 11)
(cc 11 5)
( + (cc 11 4) (cc -39 5))
( + (+ (cc 11 3) (cc -14 4)) 0)
( + (+ (+ (cc 11 2) (cc 1 3)) 0) 0)
( + (+ (+ (+ (cc 11 1) (cc 6 2)) (+ (cc 1 2) (cc -9 3))) 0) 0)
( + (+ (+ (+ (+ (cc 11 0) (cc 10 1)) (+ (cc 6 1) (cc 1 2)) (+ (+ (cc 1 1) (cc -4 2)) 0)) 0) 0)

….
order of growth of space 2^n
order of growth of steps n

E1.15
(sine 12.15)
(p (sine 4.05))
(p (p (sine 1.35)))
(p (p (p (sine 0.45))))
(p (p (p (p (sine 0.15)))))
(p (p (p (p (p (sine 0.03))))))
(p (p (p (p (p (p (sine 0.01)))))))

p is applied 6 times.
order of growth of space log3(n)
order of growth of space log3(n)

E1.16
(define (exp b n)
   (exp-iter 1 b n))

(define (even? n)
    (= (remainder n 2) 0))

(define (exp-iter a b counter)
    (cond ((= counter 0) a)
          ((even? counter) (exp-iter a 
                                     (square b)
                                     (/ counter 2)))
          (else (* b (exp-iter a 
                               (square b)
                               (/ (- counter 1) 2))))))

E1.17
(define (double x)
    (* 2 x))
(define (halve x)
    (/ x 2.0))
(define (fast-multi a b)
    (cond(( = b 1) a)
         ((even? b) (fast-multi (double a)
                                (halve b)))
         (else (+ a (fast-multi (double a)
                                (halve (- b 1)))))))

E1.18 same above

E1.19
(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   (+ (square p) (square q))      ; compute p'
                   (+ (* 2 (* p q)) (square q))     ; compute q'
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))

E1.20
normal-order (fully expand and then reduce)
(gcd 206 40)
(gcd (gcd 40 (remainder 206 40)/*1*/)
(gcd (gcd (gcd 6/*1*/ (remainder 40 6/*1*/))))
(gcd (gcd (gcd (gcd (remainder 206 40) (remainder 40)….

7 times
applicative-order 
4 times

E1.21
(smallest-divisor 19)
19
 (smallest-divisor 199)
199
(smallest-divisor 1999)
1999
 (smallest-divisor 19999)
7

E1.22

(define (search-for-primes a b)
    (search-for-primes-iter (+ a 1) b))
(define (search-for-primes-iter counter b)
    (if (< counter b)
        ((timed-prime-test counter)
         (search-for-primes-iter (+ counter 1) b))))
(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime (- (runtime) start-time))))
(define (prime? n)
  (= n (smallest-divisor n)))

=======================================


 (search-for-primes 1000 1020)
1009 *** 3
1013 *** 3
1019 *** 3

(search-for-primes 10000 10200)

10007 *** 9
10008
10009 *** 9
10037 *** 9

(search-for-primes 100000 100200)
100003 *** 26
100019 *** 29

100043 *** 26
(search-for-primes 100000 100200)
1000003 *** 87
1000033 *** 84

1000037 *** 84

YES
E1.23

(define (next-iter counter)
    (if (= 0 (remainder counter 2))
        (next-iter (+ counter 1))
        counter))
(define (next test-divisor)
    (next-iter (+ test-divisor 1)))

(define (smallest-divisor n)
  (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (next test-divisor)))))

(timed-prime-test 1009)

1009 *** 217
1013 *** 8
1019 *** 8
10007 *** 13
10009 *** 13
10037 *** 14
100003 *** 32
100019 *** 31
100043 *** 35
1000003 *** 88
1000033 *** 91
1000037 *** 87

Ratio is not 2, the larger the n is, the ratio is closer to 1.
I guess something is wrong with my next function. 

E1.24 fast-prime?
1009 *** 18
1013 *** 19
1019 *** 20
10007 *** 24
10009 *** 22
10037 *** 24
100003 *** 12750
100019 *** 38
100043 *** 28
1000003 *** 31
1000033 *** 35
1000037 *** 38

constant factor

E1.25
YES

E1.26
(* n n) use normal order, expand all then reduce, calculate exp more times
(square n) use applicative order

E1.27
(define (fermat-test n)
  (try-it-iter 2 n))

(define (try-it-iter a n)
   (if (< a n)
       (if (= (expmod a n n) a)
           (try-it-iter (+ a 1) n)
           false)
        true))

E1.28
(define (miller-rabin-test n)
  (define (try-it a)
     (= (expmod a (- n 1) n) 1))
  (try-it (+ 2 (random (- n 2)))))

(define (find-nontrivial? x m)
  (if (and (and (not (= x 1)) 
                (not (= x (- m 1))))
           (= (remainder (square x) m) 1))
      0
      (remainder (square x) m)))
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
          (find-nontrivial? (expmod base (/ exp 2) m) m))
        (else
          (remainder (* base (expmod base (- exp 1) m))
                     m))))
E1.29
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))

(define (simpson f a b n)
  (define h (/ (- b a) n))
  (define (inc x) (+ x 1))
  (define (y k)
    (f (+ a (* k h))))
  (define (term k)
    (* (cond ((odd? k) 4)
             ((or (= k 0) (= k n)) 1)
             ((even? k) 2))
       (y k)))
  (/ (* h (sum term 0 inc n)) 3))
(define (cube x)
    (* x x x))

(simpson cube 0 1 1000.0)
0.2500000000000003
(simpson cube 0 1 100)
1/4
